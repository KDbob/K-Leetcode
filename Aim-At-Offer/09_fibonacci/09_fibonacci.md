#### [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```


斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```tex
输入：n = 2
输出：1
```

**示例 2：**

```tex
输入：n = 45
输出：134903163
```



# 解题思路 

> 如果单纯地使用递归算法，会出现很多重复的计算。导致占用内存过大，计算时间也会过大，因此使用动态规划是恰当的方法

使用动态规划具有以下特点：

1. 自底向上
2. **每个问题只解一次**
3. 所有字问题都已解

**准备数据结构**

> 动态规划有个特点，需要借助一个辅助的数据结构来存储字问题的解

- 这里很容易想到用一个一位维数组。

  ```c++
  int A[N];
  A[0] = 0; // a
  A[1] = 1;	// b
  A[2] = 1;	// sum
  ...
  A[n] = ...
  ```

- 但是题目只需要计算出第n个fibonacci的值，而且0～n所保存的数都是可以计算得来。因此只需要在循环中不断更新A[n-1]，A[n-2]的值，就能在循环遍历后得到A[n]的值:

  ```c++
  int A[N];
  A[0] = 0; // 
  A[1] = 1;	// a = b
  A[2] = 1;	// b = sum
  A[3] = 2; // sum = a + b
  ...
  A[n] = ...
  ```

  实现后的动态规划生成值如下：

  ```c++
  int a = 0, b = 1, sum;
  for (int i = 0; i < n; i++) {
      sum = (a + b);
      a = b;
      b = sum;
  }
  return a;
  ```

  这个代码求A[n]的话，其实会多计算一次A[n+1]的值，不过为了规整输出可以忽略不计。

  

# 知识点总结

- 改进的方法：在本题中用三个不断更新的变量取代了数组结构
  - 将空间复杂度从O(n)→O(1)

- 循环求余法（暂时没理解）：

  > 大数越界： 随着 nn 增大, f(n)f(n) 会超过 Int32 甚至 Int64 的取值范围，导致最终的返回值错误。

**求余运算规则**： 设正整数 x, y, px,y,p ，求余符号为 \odot⊙ ，则有 (x + y) \odot p = (x \odot p + y \odot p) \odot p(x+y)⊙p=(x⊙p+y⊙p)⊙p 。
**解析**： 根据以上规则，可推出 f(n) \odot p = [f(n-1) \odot p + f(n-2) \odot p] \odot pf(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙p ，从而可以在循环过程中每次计算 sum = (a + b) \odot 1000000007sum=(a+b)⊙1000000007 ，此操作与最终返回前取余等价。

