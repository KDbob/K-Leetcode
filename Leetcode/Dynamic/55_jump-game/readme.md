#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

> #动态规划 

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

 

# 解题（动态规划🐱）

## 方法一：达到的最远位置

> 只需要得到每个位置能够达到的最远位置，完整遍历一边说明可以达到远点
>
> 动态规划思想：每一步都依赖前一步的解

**算法流程**

更新可以到达的最远位置reach

1. 计算出0～n-1位置的每个位置能达到的最远位置reach
   - <u>如果index超过了reach，说明index不可以达到★</u>。此时返回false

2. 如果所有位置都遍历到了，返回true

**代码实现**

```c++
bool canJump(vector<int> &nums) {
    int n = nums.size();
    int reach = 0;
    for (int i = 0; i < n; ++i) {
        if (i > reach) return false;    // 说明这一步不能通过前者达到，那么后面更达不到了
        int x = i + nums[i];
        if (x > reach) reach = x;
    }
    return true;
}
```

**优化点**

- 如果遍历过程中有个位置达到的位置很远（大于等于数组长度），可以提前返回true

## 方法二：最早开始位置

> 从后往前推算，如果满足条件标记

💡如何标记？

> 只需一个变量维护最后可达的位置，初始是最后一个位置n-1
>
> 前个位置如果可达的话，更新为n-2，以此类推：最小的位置0

#### 算法流程

0. 从最后的元素开始，标记可到达
1. 从最后元素的前一位开始判断：是否能到达最后元素，以此类推
   - 可到达
   - 不可到达
2. 遍历结束，如果初始位置可以到达，则说明是可到达的。

#### 数据结构

`last=n-1`:最后位置★

#### 代码实现

```c++
bool canJump2(vector<int> &nums) {
    int n = nums.size();
    int last = n - 1;
    for (int i = n - 2; i >= 0; --i) {
        if ((nums[i] + i) >= last) {
            last = i;
        }
    }
    return last == 0;
}
```

# 总结

- python中的遍历（倒序）写法

  ```python
  >>> for i in range(5,-1,-1):
  ...     print(i)
  ... 
  5
  4
  3
  2
  1
  0
  ```

  

#### 



