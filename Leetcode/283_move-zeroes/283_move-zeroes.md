#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```


说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

# 解题思路

## 双指针法

#### 准备数据结构

指针i：用于指向零元素

指针j：用于i指向的**零元素后面的第一个非零元素**

#### 算法流程

0. i指向0，j指向0后面的第一个非零元素
1. 交换两者的值
   - i继续遍历指向下一个0（或者仍是这个0）
   - j继续遍历，寻找下一个非零元素
2. 当j遍历时算法结束

```c++
void moveZeroes(vector<int> &nums) {
    int i = 0;
    while (i <nums.size() && nums[i] != 0) i++;	// 找到第一个0元素
    int j = i +1;
    while (j < nums.size() && nums[j] == 0) j++;// 找到0元素后的第一个非0元素
    while (j < nums.size()) {
        int tem = nums[i];
        nums[i] = nums[j];
        nums[j] = tem;
        j +=1;
                //        while (i <nums.size() && nums[i] != 0) i++;  等价于 i+=1;
        i +=1;  // 此处num[i+1]一定是0，因为要么是i+1本身就是0，要么是j指向的是i+1,刚好交换了值。
        while (j < nums.size() && nums[j] == 0) j++;	// 找到之后的第一个非0元素
    }
}
```

### 复杂度分析

时间复杂度：$O(n)$

> 因为i和j的遍历是交替递进的。最多遍历数组长度

空间复杂度：$O(1)$

```c++

```

