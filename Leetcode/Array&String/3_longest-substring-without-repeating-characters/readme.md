#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

> #滑动窗口

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

 

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

 

# 解题

## 方法一：暴力

1. 遍历找到所有子串 $O(n^2)$
2. 判断子串是否仅含唯一字符
   - 使用hash表

时间复杂度：$O(n^3)$

空间复杂度：$O(m)$：哈希表

## 方法二：滑动窗口

> 对暴力解的优化，可以将第一步遍历时间下降到$O(n)$。
>
> 同时复用hash表的判重，从而整体复杂度下降到$O(n)$

### 思路

abcabcbb 为例，找出**从每一个字符开始的，不包含重复字符的最长子串**

> 其中括号中表示选中的字符以及最长的字符串

以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；
以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；
以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb
以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb
以 abca(b)cbb 开始的最长字符串为 abca(bc)bb
以 abcab(c)bb 开始的最长字符串为 abcab(cb)b
以 abcabc(b)b 开始的最长字符串为 abcabc(b)b
以 abcabcb(b) 开始的最长字符串为 abcabcb(b)

**发现规律**：子串的位置也是递增的。

> 遍历找到所有子串 $O(n^2)$下降到$O(n)$

**原理证明**

这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk 。那么当我们选择第 k+1 个字符作为起始位置时，**首先从 k+1 到 rk的字符显然是不重复的**🐱(相当于复用了之前的判重)，并且由于少了原本的第 k 个字符，我们可以尝试继续增大  ，直到右侧出现了重复字符为止。

### 算法流程

1. 从每个字符开始使用《滑动窗口》枚举

   1. 对于从这个字符开始的进行增大子串，直到不重复为止，并记录子串的长度

      > 重要：擦除上个存在于hash表中的起始位置★

2. 返回找到最长的子串

### 代码实现

```C++
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> set;
        int n = s.size();
        int rk = -1, ans = 0;
        for (int k = 0; k < n; ++k) {
            if (k != 0) {
                set.erase(s[k - 1]);    // 滑动窗口上个起始的元素
            }
            while (rk + 1 < n && !set.count(s[rk + 1])) {
                set.insert(s[rk+1]);
                ++rk;
            }
            ans = max(ans, rk - k + 1);
        }
        return ans;
    }
```

# 总结

- 滑动窗口的思想一般是可以重复利用前面的工作