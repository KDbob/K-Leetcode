#### [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

颠倒给定的 32 位无符号整数的二进制位。

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。


进阶:
如果多次调用这个函数，你将如何优化你的算法？

示例 1：

```
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

示例 2：

```
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```

# 解题思路

## 方法一：逐位颠倒

将n视作一个长为32的二进制串，从低位往高位枚举n的每一位

#### 准备数据结构

`uint32_t rev = 0`：用于累加每次遍历的枚举

#### 算法思路

1. 从低位往高位枚举（32次）

   - 可以用1&n，得到的结果是最低位，假设是第0位。

     > 执行&操作后，n右移1位，下次&操作可以得到次低位。

   - 反转后应该是最高位：31-0=32位

     > 可以视作是左移31位。

   - 将每次枚举获得的值执行｜操作可以得到累加的结果

     > 例如100｜010=110

2. 枚举结束返回rev

   > 优化：不一定需要遍历32次：当n=0时直接结束循环即可。

#### 算法实现

```c++
uint32_t reverseBits(uint32_t n) {
    uint32_t rev = 0;
    for (int i = 0; i < 32 && n > 0; ++i) {
        rev |= (n & 1) << (31 - i);
        n = n >> 1;
    }
    return rev;
}
```

#### 复杂度分析

时间复杂度：$O(log_2n)$

> 最多32次遍历

空间复杂度：$O(1)$



## 方法二：位运算分治（TODO）

# 知识点总结

- |=或等操作可以将枚举得到的值累加

  > 100｜010｜001=111

